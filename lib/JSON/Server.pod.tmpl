[% start_year=2021 %]
[% MACRO example(file) BLOCK %]
[%- pl =  file _ ".pl" -%]
[%- out = file _ "-out.txt" -%]
[% INCLUDE $pl | xtidy %]
(This example is included as L<F<[% pl %]>|https://fastapi.metacpan.org/source/BKB/JSON-Server-[% info.version %]/examples/[% pl %]> in the distribution.)
[% END %]
[% MACRO since(version) BLOCK -%]
This method was added in version [% version %] of the module.
[%- END %]
=encoding UTF-8

=head1 NAME

[% info.colon %] - JSON-only server

=head1 SYNOPSIS

[% example("synopsis") %]

Then test your server:

[% INCLUDE "synopsis-example.txt" | xtidy %]

=head1 VERSION

This documents version [% info.version %] of [% info.name %]
corresponding to L<git commit [% commit.commit %]|[% info.repo
%]/commit/[% commit.commit %]> released on [% commit.date %].

=head1 DESCRIPTION

This sets up an internet socket through which JSON passes.

=head1 METHODS

=head2 new

    my $js = JSON::Server->new (handler => \& something, data => $my_data,
		                port => '3737');

=over

=item data

Your data which you want to pass to the handler. This can be omitted,
in which case the handler will be sent an undefined value as its first
argument.

=item handler

Your handler (callback).

    sub handler
    {
        my ($data, $input) = @_;
        return {error => "I don't like this input"};
    }
    my $js = JSON::Server->new (handler => \&handler);

The handler function should accept two arguments, the first is the
user data which is supplied to L</new> and the second is the parsed
input from the socket. It should return one value which is then passed
back through the socket as JSON. The user handler function does not
serialize or deserialize anything, usually it would take a hash
reference as an argument and return a hash reference as result.

If you do not supply a handler, the server substitutes an echo
function which merely returns your input back to you, and prints a
warning.

=item port

The port to serve on. This needs to be specified, there is no default
value.

=back

=head2 serve

    $js->serve ();

Serves JSON on the specified port. Input is JSON, output is
JSON. Non-JSON input results in a response of the form
C<{"error":"invalid JSON"}> being returned. What is or is not valid
JSON is decided by L<JSON::Parse/valid_json>.

=head1 JSON

=head2 Booleans

Unlike many programming languages, Perl doesn't have C<true> and
C<false>, which means that boolean literals (C<true> and C<false>) can
become something of an issue when using JSON. In L<JSON::Create> there
are all kinds of options for using booleans, but JSON::Server doesn't
give access to the underlying module. 

However, as a way to get booleans, if you need them, JSON::Server uses
the CPAN module L</boolean>. If you need C<true> or C<false> in your
JSON output, add

    use boolean;

in your code and then

    my $value = true;

etc. to get C<true> and C<false> literals in the JSON.

Perl's built-in C<undef> will produce JSON C<null>.

Boolean support is planned for a future version of JSON::Parse, and
the use of the L</boolean> module will no longer be necessary.

=head2 Unicode

Perl doesn't allow character-encoded strings through sockets, so
character input is automatically downgraded on output using
L<JSON::Create/downgrade_utf8>, and since JSON is a UTF-8 only format,
all input is upgraded to character input. L</JSON::Parse> currently
doesn't have the facility to do this, so L</Unicode::UTF8> is used for
that task.

Optional character-string upgrading is planned for a future version of
JSON::Parse, and use of the Unicode::UTF8 module will no longer be
necessary.

=head1 CONTROLLING THE SERVER

There is a "backdoor" for controlling the server. To access this, you
need to send an object (a hash reference) with the key
C<JSON::Server::control>,

    send_to_server ({'JSON::Server::control' => 'stop'});

It accepts the following commands:

=over

=item stop

C<{"JSON::Server::control":"stop"}> causes the server to return from
its event loop. It prints a response
C<{"JSON::Server::response":"stopping"}> to acknowledge the control
message.

=back

Whatever else is sent in the object with the control message is
discarded.

=head1 DEPENDENCIES

=over

=item L<boolean>

C<boolean> is used as the compatibility module for putting C<true> or
C<false> values into the JSON.

=item L<IO::Socket>

This is used to communicate the information to and from the client.

=item L<JSON::Create>

This is used to encode the response JSON from a native structure.

=item L<JSON::Parse>

This is used to decode the received JSON into a native structure.

=item L<Unicode::UTF8/decode_utf8>

This is used to convert the received JSON from the socket before it is
passed to L</JSON::Parse>.

=back

=head1 SEE ALSO

=over

=item L<JRPC>

=item L<JSON::RPC::Dispatcher>

=item L<JSON::RPC>

=item L<RPC::JSON>

=back

[% INCLUDE "author" %]
