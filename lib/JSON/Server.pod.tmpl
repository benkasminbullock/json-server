[% start_year=2021 %]
[% MACRO example(file) BLOCK %]
[%- pl =  file _ ".pl" -%]
[%- out = file _ "-out.txt" -%]
[% INCLUDE $pl | xtidy %]
(This example is included as L<F<[% pl %]>|https://fastapi.metacpan.org/source/BKB/JSON-Server-[% info.version %]/examples/[% pl %]> in the distribution.)
[% END %]
[% MACRO since(version) BLOCK -%]
This method was added in version [% version %] of the module.
[%- END %]
=encoding UTF-8

=head1 NAME

[% info.colon %] - JSON-only server

=head1 SYNOPSIS

[% example("synopsis") %]

Then test your server:

[% INCLUDE "synopsis-example.txt" | xtidy %]

=head1 VERSION

This documents version [% info.version %] of [% info.name %]
corresponding to L<git commit [% commit.commit %]|[% info.repo
%]/commit/[% commit.commit %]> released on [% commit.date %].

=head1 DESCRIPTION

This sets up an internet socket through which JSON passes.

=head1 METHODS

=head2 new

    my $js = JSON::Server->new (handler => \& something, data => $my_data,
		                port => '3737');

=over

=item data

Your data which you want to pass to the handler. This can be omitted,
in which case the handler will be sent an undefined value as its first
argument.

=item handler

Your handler (callback).

    sub handler
    {
        my ($data, $input) = @_;
        return {error => "I don't like this input"};
    }
    my $js = JSON::Server->new (handler => \&handler);

The handler function should accept two arguments, the first is the
user data which is supplied to L</new> and the second is the parsed
input from the socket. It should return one value which is then passed
back through the socket as JSON. The user handler function does not
serialize or deserialize anything, usually it would take a hash
reference as an argument and return a hash reference as result.

If you do not supply a handler, the server substitutes an echo
function which merely returns your input back to you, and prints a
warning.

=item port

The port to serve on. This needs to be specified, there is no default
value.

=back

=head2 serve

    $js->serve ();

Serves JSON on the specified port. Input is JSON followed by a zero
byte, output is JSON followed by a zero byte. Non-JSON input results
in a response of the form C<{"error":"invalid JSON"}> being
returned. What is or is not valid JSON is decided by
L<JSON::Parse/valid_json>.

=head1 JSON

=head2 Booleans

Unlike many programming languages, Perl doesn't have C<true> and
C<false>, which means that boolean literals (C<true> and C<false>) can
become something of an issue when using JSON. 

If you need booleans, import L<JSON::Create::Bool> from the
L<JSON::Create> distribution.

    use JSON::Create::Bool;

in your code and then

    my $value = true;

etc. to get C<true> and C<false> literals in the JSON.

Perl's built-in C<undef> will produce JSON C<null>.

=head2 Unicode

Perl doesn't allow character-encoded strings through sockets, so
character input is automatically downgraded on output using
L<JSON::Create/downgrade_utf8>, and since JSON is a UTF-8 only format,
all input is upgraded to character input.

=head1 CONTROLS

=head2 Controlling the server

There is a "backdoor" for controlling the server. To access this, you
need to send an object (a hash reference) with the key
C<JSON::Server::control>,

    send_to_server ({'JSON::Server::control' => 'stop'});

It accepts the following commands:

=over

=item close

C<{"JSON::Server::control":"close"}> causes the server to close the
connection. It prints a response
C<{"JSON::Server::response":"closing"}> to acknowledge the control
message.

=item stop

C<{"JSON::Server::control":"stop"}> causes the server to return from
its event loop. It prints a response
C<{"JSON::Server::response":"stopping"}> to acknowledge the control
message.

=back

Whatever else is sent in the object with the control message is
discarded.

=head2 JSON::Client

There is an example client module called JSON::Client in the
distribution. At the moment, this is used for testing the
server. There is no documentation, so please see the files in the
F<t/> directory of this distribution for examples of use.

In the practical case for which I'm using this module, I use it to
communicate from a Perl server to a Go (golang) client, so most of the
examples I have of actual use of the module don't involve a Perl
client at all, only a Perl server. It's difficult to include a useful
Go example in the module since, unlike Perl, Go associates a type with
every variable and "standard library" JSON parsing in Go involves
advanced knowledge of the data structure to be received, unless you
use whacky empty interface nonsense. I don't have any examples of that
since I don't do such stupid things, so JSON::Client is the best I can
offer.

=head1 DEPENDENCIES

=over

=item L<IO::Select>

=item L<IO::Socket>

This is used to communicate the information to and from the client.

=item L<JSON::Create>

This is used to encode the response JSON from a native structure.

=item L<JSON::Parse>

This is used to decode the received JSON into a native structure.

=back

=head1 SEE ALSO

=over

=item L<JRPC>

=item L<JSON::RPC::Dispatcher>

=item L<JSON::RPC>

=item L<RPC::JSON>

=back

[% INCLUDE "author" %]
